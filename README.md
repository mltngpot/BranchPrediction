# BranchPrediction
My idea of 2 level branch prediction for Computer Architecture.
This is a C++ project that utilizes the CMake build system.

## Data Structures

### PCEntry
Each line from the provided gccSmall.trace file is saved as as struct that contains an unsigned int for the address and a bool for the taken/not-taken. 

### Branch History Register
The BHR contains an array of Pattern History Tables (PHT). It also contains an array of unsigned ints to keep track os the entries. I did it this way for speed, but I am sure on a chip it would be done differently. By default there are 512 entries. 

### Pattern History Table
The PHT was desgined to allow for scaling above patterns 4 bits, but this did not seem to work and it only tracks 4 bits. It uses an unsigned int to keep track of the pattern and an unsigned int to keep track of the history counters. The unsigned int breaks down from 32 bits to 16 bit pairs representing values 0-3 (00-11). A bit mask is used to isolate the counter we are interested in and a prediction is made.

## Algorithm

## Source Code
Available at http://github.com/mltngpot/BranchPrediction

## Compilation && Installation

`cmake --build .`
copy gccSmall.trace to directory of executable.

## Running
Simply running the command at any prompt in the directory of the executable should execute. 
`./BranchPrediction`

The size of the BHR, PHT and the name of the input file can be changed from the command line.

`-pht <New Pattern Size>`
`-bhr <Entries in BHR>`
`-trace <New Trace file>`

## Accuracy
Using the default settings of 4 bit pattern length and 512 entries in the BHR, an accuracy of 69.9785% is achived. Simply increasing the BHR entries to 1024 increases the accuracy to 81.4508%.

## Cost
Everything has a cost. At default, assuming that only the 4 bit history is stored and not wasting 28 bits with an int and everything is optimal.

`<BHR Entries> * (<address> + <Pattern size> + 2 ^ (<pattern size> + 1) + <Least Recently Used>) = <Total cost>`

Default value in bits:

512 * (32 + 4 + 2 ^ 5 + 1) = 35328bits

                              4416Bytes

                            4.3125KBytes

## Analysis
Assuming that the LRU operation only requires 1 bit AND is 100% optimal, I believe this cost to be acceptable for the nearly 70% accuracy rate. Jumping the size of the BHR up to 1024 is better and would only require about 8.6KB for the 81% yield. Above that the return deminishes greatly. I am not a hardware guy but given current L1 cache sizes of 64KB on an i7, I think this is of a sufficent size.

## Output
The output can be generated by running the program or looking in the root directory. Either way the output file is called `output.trace` and is formated:

`<unsigned int address> <branch was taken> <prediction> <prediction accuracy>`